---
title: 프로그래머스 - 08
author: Psmin
data: 2023-04-20 15:17:32 +0900
categories: [코딩테스트, Programmers]
tags: [programmers]
---

# Level 1

---

## 가장 가까운 같은 글자

문자열 s가 주어졌을 때, s의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.

예를 들어, s="banana"라고 할 때, 각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.

- b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.

- a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.

- n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.

- a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.

- n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.

- a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.

따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.

문자열 s이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.

```js
function solution(s) {
  let map = new Map();

  return s.split("").map((x, index) => {
    // undefined면 첫 저장이므로 -1
    let idx = map.get(x) == undefined ? -1 : map.get(x);

    // 문자의 index 값으로 Map 객체 갱신
    map.set(x, index);

    return idx == -1 ? idx : index - idx;
  });
}
```

---

### 풀이

문자열을 배열로 변환한 후 Map 메소드로 앞에서부터 순서대로 반복문을 돌린 후 반환된 배열을 return

Map 객체에 각 문자의 index 값을 저장합니다.

Map에 문자를 key로 값이 undefined이면 처음 나온 것이므로 -1을 return

undefined가 아니라면 현재 문자의 index값에서 Map 객체에 저장되어있던 값를 뺸 값을 return

또한, 매 반복마다 Map 객체를 갱신합니다.

---

## 소수 찾기 - Level 1

1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

```js
function solution(n) {
  let answer = 0;

  function isPrime(n) {
    for (let i = 2; i <= Math.sqrt(n); i++) {
      if (n % i == 0) return false;
    }

    return true;
  }

  for (let i = 2; i < n; i++) {
    if (isPrime(n)) answer++;
  }

  return answer;
}
```

효율성 테스트 실패한 이유

- isPrime 함수는 2 ~ n의 제곱근 까지의 수를 모두 탐색합니다.
  : 시간 초과

- set 객체를 이용하거나 다른 방식으로 풀어야합니다.

---

### 다른 풀이

```js
function solution(n) {
  var primes = [];

  function isPrime(n) {
    for (let x of primes) {
      if (x > Math.sqrt(n)) return true;
      if (n % x == 0) return false;
    }
  }

  for (let i = 2; i <= n; i++) {
    if (isPrime(i)) primes.push(i);
  }

  return primes.length;
}
```

- 판별함수를 통과하면 cnt를 올리는게 아니라 해당 소수를 배열로 저장합니다.
- 소수판별함수인 isPrime은 2 ~ n의 제곱근을 모두 탐색에서 저장된 소수들 중에 n의 제곱근보다 낮은 수 중 n의 약수가 있는 지 탐색합니다.

시간을 줄여 효율성 테스트를 통과할 수 있었습니다.

---

## 실패율

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42889)

전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.

실패율은 다음과 같이 정의한다.
스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수

```js
function solution(N, stages) {
  let map = new Map();

  // Map 객체 : 스테이지 번호, 각 스테이지에 있는 사용자 수
  stages.forEach((x, index) => {
    if (x <= N) map.set(x, map.get(x) + 1 || 1);
  });

  let n = stages.length;

  for (i = 1; i <= N; i++) {
    let cnt = map.get(i);

    if (cnt) {
      // 스테이지 번호, 실패율 로 변경
      map.set(i, cnt / n);
      n -= cnt;
    } else {
      // 배열에 없는 번호에 실패율 0 설정
      map.set(i, 0);
    }
  }

  return [...map]
    .sort((a, b) => {
      // 실패율이 같으면 번호 순, 다르면 실패율이 낮은 순서로
      return b[1] == a[1] ? a[0] - b[0] : b[1] - a[1];
    })
    .map(([x, _]) => x); // 스테이지 번호만 배열로 정렬
}
```

가독성이 좋지못한 코드가 되었다 다른 풀이를 살펴보자.

---

### 다른 풀이

```js
function solution(N, stages) {
  let result = [];
  for (let i = 1; i <= N; i++) {
    // i번 스테이지에 도달한 사용자 수
    let userCnt = stages.filter((x) => x >= i).length;

    // 현재 i번 스테이지에 머물러 있는 사용자 수
    let curr = stages.filter((x) => x === i).length;

    // 스테이지 번호와 실패율을 배열로 result 배열에 push
    result.push([i, curr / reach]);
  }

  // 실패율 순서로 정렬
  // for문에서 i를 1부터 순서대로 진행했으므로 번호 순 정렬 생략 가능
  result.sort((a, b) => b[1] - a[1]);

  return result.map((x) => x[0]);
}
```
