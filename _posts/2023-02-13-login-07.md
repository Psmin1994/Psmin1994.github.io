---
title: 로그인 페이지 만들기 - 07 (crypto)
author: Psmin
data: 2023-02-13 23:07:02 +0900
categories: [Project, Login Page]
tags: [crypto, passport-local]
---

# Crypto 모듈을 이용해 비밀번호를 암호화해보자.

---

## 비밀번호 암호화

**_crypto 모듈_**을 이용해 비밀번호를 암호화해서 DB에 저장해보겠습니다.

먼저 미들웨어로 모듈화해 <u>회원가입 시 사용자가 입력한 비밀번호를 암호화하는 함수</u>와 <u>로그인 시 사용자가 입력한 비밀번호를 검증하는 함수</u>를 작성합니다.

이후 Controller에서 Model에 접근하기 전 모듈을 불러와 비밀번호를 변환한 후 작업하도록 수정해보겠습니다.

---

### 암호화 및 검증 함수

**_middlewares_** 폴더에 `crypto.js` 파일을 만들어 모듈화해 사용하겠습니다.

- `createPasswordAndSalt 함수`  
  : 회원가입 시 사용자가 입력한 비밀번호(password)를 인자로 받아 salt + $ + key 문자열로 반환하는 함수

  - `salt` : 임의로 생성된 문자열
  - `key` : crypto 모둘의 pbkdf2Sync 메서드로 생성한 암호화된 비밀번호 문자열

- `userPasswordVerify 함수`  
  : 사용자가 입력한 비밀번호 (userInputPassword)와 DB에 저장된 암호화된 비밀번호 (PasswordAndSalt)를 비교하는 함수
  >

```js
// middlewares/crypto.js
import crypto from "crypto";

// 암호화된 비밀번호 생성 함수
const createPasswordAndSalt = (password) => {
  const salt = crypto.randomBytes(64).toString("base64");

  const key = crypto
    .pbkdf2Sync(password, salt, 104906, 64, "sha512")
    .toString("base64");

  return `${key}$${salt}`;
  // 암호화된 비밀번호와 임의로 생성된 salt를 '$'를 기준으로 이어줍니다.
};

// 비밀번호 검증 함수
// 사용자의 입력 값과 데이터베이스에 저장된 암호화된 값을 비교해 검증합니다.
const userPasswordVerify = (userInputPassword, PasswordAndSalt) => {
  const [encrypted, salt] = PasswordAndSalt.split("$");

  const userInputEncrypted = crypto
    .pbkdf2Sync(userInputPassword, salt, 104906, 64, "sha512")
    .toString("base64");

  if (userInputEncrypted === encrypted) {
    return true;
  } else {
    return false;
  }
};

export { createPasswordAndSalt, userPasswordVerify };
```

---

### Controller 수정

**_Controller_**에서 **_model_**에 요청하기 전 비밀번호를 암호화합니다.

```js
import UserStorage from "../models/model_user.js";
import {
  createPasswordAndSalt,
  userPasswordVerify,
} from "../middlewares/crypto.js";

const output = {
  ...
};

const process = {
  login: async (req, res) => {
    try {
      const idChecked = await UserStorage.checkId(req.body.id);

      let response = {};

      if (idChecked) {
        // post 방식으로 넘어온 데이터는 req.body에 담겨 있습니다.
        const { _, PasswordAndSalt, userName } = await UserStorage.getUserInfo(
          idChecked.id
        );

        // 비밀번호 확인 작업
        // req.body.password : 사용자가 로그인 시 입력한 비밀번호
        // password : 사용자가 입력한 id가 존재할 때 DB에서 가져온 저장된 암호화된 비밀번호
        let password = await userPasswordVerify(
          req.body.password,
          PasswordAndSalt
        );

        if (password === req.body.password) {
          // 로그인 성공 했을 때
          req.session.is_logined = true;
          req.session.name = nickName;

          response.success = true;
        } else {
          response.success = false;
          response.msg = "비밀번호가 틀렸습니다.";
        }
      } else {
        response.success = false;
        response.msg = "존재하지 않는 아이디입니다.";
      }

      res.json(response);
    } catch (err) {
      // 간단한 에러 처리문 작성
      const response = {
        success: false,
        msg: "로그인을 할 수 없습니다.\n잠시 후 다시 시도해주세요.",
      };

      res.json(response);
    }
  },

  register: async (req, res) => {
    try {
      const idCheck = await UserStorage.checkId(req.body.id);

      let response = {};

      if (idCheck) {
        response = { success: false, msg: "아이디가 존재합니다." };
      } else {
        // 사용자가 입력한 비밀번호를 createPasswordAndSalt 로 암호화합니다.
        req.body.password = await createPasswordAndSalt(req.body.password);

        // DB에 새로운 사용자 등록
        response = await UserStorage.createUser(req.body);
      }

      res.json(response);
    } catch (err) {
      // 간단한 에러 처리문 작성
      const response = {
        success: false,
        msg: "회원가입을 할 수 없습니다.\n 잠시 후 다시 시도해주세요.",
      };

      res.json(response);
    }
  },

  logout: (req, res) => {
    ...
  },
};

export default { output, process };
```

![crypto-rds](/assets/img/crypto-rds.png){: .w-80 .normal}

데이터베이스에 암호화된 비밀번호가 담겨있는 것을 확인할 수 있습니다.
