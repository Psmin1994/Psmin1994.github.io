---
title: 로그인 페이지 만들기 - 09 (JWT & Redis)
author: Psmin
data: 2023-02-23 17:38:23 +0900
categories: [Project, Login Page]
tags: [jsonwebtoken, redis]
---

# JWT를 이용해 로그인 기능을 구현해보자.

- 세션 저장소로 Redis를 활용해보자.

---

## 구현 로직

![access-refresh-jwt](/assets/img/access-refresh-jwt.png){: .w-80 .normal}

위 그림을 참고하여 **Access Token**과 **Refresh Token**을 모두 이용한 서버 인증 방식으로 구현해보겠습니다.

1. 사용자가 **로그인을 시도**합니다.

2. 서버는 사용자를 DB를 통해 조회하고 **사용자 확인에 성공하면 RefreshToken을 발급하고 Redis에 저장**합니다.

3. 또한, **AccessToken을 발급하고 사용자에게 응답**해줍니다.

4. 다음 요청부터 사용자는 로그인이 필요한 서비스에는 발급받은 **AccessToken을 담아 요청**합니다.

5. **AccessToken이 유효**하다면 DB조회 없이 서버는 **바로 서비스를 제공**합니다.

6. **AccessToken이 만료**됐다면 **RefreshToken을 통해 AccessToken을 재발급**합니다.

7. **RefreshToken도 만료**됐다면 **다시 로그인**이 필요함을 알려줍니다.

---

## express + JWT

기존의 **Session + Cookie** 방식에서 **jwt + cookie** 방식으로 바꿔보겠습니다.

- **사용할 모듈**

  - jsonwebtoken 모듈
  - redis 모듈

**Redis**는 Redis 클라우드 서비스인 `redisLabs`을 이용하겠습니다.

---

## app.js 수정하기

기존의 Session 관련 내용들은 지워줍니다.

```js
import express from "express";
import path from "path";
import "dotenv/config";
import bodyParser from "body-parser";
import cookieParser from "cookie-parser";
import passport from "passport";
import passportConfig from "./src/config/passport/index.js";

import userRouter from "./src/routes/route_user.js";

const app = express();

const __dirname = path.resolve();

// 앱 세팅
app.set("views", "./src/views");
app.set("view engine", "ejs");

// 미들웨어
app.use("/", express.static(`${__dirname}/src/public`));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cookieParser(process.env.COOKIE_SECRET));
// cookieParser 메서드에 인자로 주어지는 secret은 환경변수로 따로 관리합니다.

app.use(passport.initialize());
passportConfig();

// router
app.use("/user", userRouter);

// error handler
app.use((err, req, res, next) => {
  console.log(err);
  res.status(500).json({
    msg: "Server Error!!",
    error: err,
  });
});

app.listen(process.env.PORT, () => {
  console.log("Server on port", process.env.PORT);
});
```

---

## jwt-util.js 만들기

**Token 생성 함수**, **Token 검증 함수**를 만들어 utils 폴더에 담아 관리하겠습니다.

- **AccessToken**은 짧은 만료기간으로 설정하고 **RefreshToken**는 긴 만료기간을 설정합니다.

- **Refresh Token**은 Redis에 저장된 것을 가져오는 방식이고, **Access Token**은 사용자가 요청 시 보낸 쿠키에서 확인하는 방식입니다.

```js
import jwt from "jsonwebtoken";
import redisClient from "../config/redis.js";

const accessTokenSecret = process.env.ACCESS_TOKEN_SECRET;
const refreshTokenSecret = process.env.REFRESH_TOKEN_SECRET;

export default {
  // AccessToken 생성 함수
  accessSign: (user) => {
    return jwt.sign(
      {
        id: user.id,
        name: user.name,
      },
      accessTokenSecret,
      {
        expiresIn: "10s", // 유효기간
        algorithm: "HS256", // 암호화 알고리즘
      }
    );
  },

  accessVerify: async (accessToken) => {
    try {
      const decoded = await jwt.verify(accessToken, accessTokenSecret);

      return {
        id: decoded.id,
        name: decoded.name,
      };
    } catch (err) {
      return jwt.decode(accessToken);
    }
  },

  refreshSign: (user) => {
    return jwt.sign({}, refreshTokenSecret, {
      expiresIn: "10s",
      algorithm: "HS256",
    });
  },

  refreshVerify: async (key) => {
    try {
      const refreshToken = await redisClient.get(key); // redis에서 refreshToken 가져오기

      await jwt.verify(refreshToken, refreshTokenSecret);

      return true;
    } catch (err) {
      return false;
    }
  },
};
```

---

## redis를 사용하는 이유

RefreshToken의 경우 서버의 Stroage에 따로 저장해서 이후 검증에 활용해야 합니다.

즉, <u>추가적인 I/O 작업이 필요</u>하다는 의미입니다.

이는 I/O 작업이 필요없는 빠른 인증 처리를 장점으로 내세우는 JWT에 어울리지 않는 해결 방식입니다.

**Redis**는 <u>In-Memory 기반의 Key-Value 기반의 NoSql DBMS</u>입니다.

간단하게 `(사용자\_id, refreshToken)` 정도로 저장할 것이고 <u>In-Memory 방식으로 Memory(Ram)에 저장되기 때문에</u> 속도가 다른 NoSQL보다 빠릅니다.

따라서, DB보다는 보다 속도가 빠르고 가벼운 `Redis`에 저장합니다.

---

### redis 설정

config 폴더에 redis설정을 해두고 import해 사용하겠습니다.

redisLabs에 생성한 redis-DB와 연동한 후 연결해줍니다.  
(사용법은 생략하겠습니다.)

```js
// config/redis.js

import redis from "redis";

const redisClient = redis.createClient({
  url: `redis://${process.env.REDIS_USERNAME}:${process.env.REDIS_PASSWORD}@${process.env.REDIS_HOST}:${process.env.REDIS_PORT}/${process.env.REDIS_DB_NUM}`,
});

redisClient.on("error", (err) => {
  console.error("Redis Client Error", err);
});

redisClient.on("connect", () => {
  console.info("Redis connected!");
});

await redisClient.connect();

export default redisClient;
```

---

### Redis에 refresh 저장하기

로그인 성공 시 토큰을 발급하면서 redis에 refreshToken을 저장합니다.

```js
import logger from "../middleware/logger.js";
import passport from "passport";
// jwt 유틸 함수 import
import jwtUtil from "../utils/jwt.util.js";
import { createPasswordAndSalt } from "../utils/crypto.util.js";
import UserStorage from "../models/model_user.js";
// redis 설정 import
import redisClient from "../config/redis.js";

const output = {
  ...
};

const process = {
  login: (req, res, next) => {
    passport.authenticate("local-login", (err, user, response) => {
      if (err) return next(err);

      if (!user) return res.json(response);

      return req.logIn(user, async (err) => {
        if (err) return next(err);

        // Access, Refresh 토큰 생성
        const accessToken = jwtUtil.sign(user);
        const refreshToken = jwtUtil.refreshSign(user);

        // redis에 사용자 아이디를 key로 refresh 토큰을 저장합니다.
        await redisClient.set(user.id, refreshToken);

        // 두 토큰을 쿠키로 발급합니다.
        res.cookie("accessToken", accessToken, {
          sameSite: "strict",
          httpOnly: true,
          secure: false,
        });

        res.cookie("refreshToken", refreshToken, {
          sameSite: "strict",
          httpOnly: true,
          secure: false,
        });

        res.status(200).json({ success: true });
      });
    })(req, res, next);
  },

  register: async (req, res, next) => {
    ...
  },

  logout: (req, res) => {
    try {
      // 로그아웃 요청시 토큰을 쿠키에서 삭제합니다.
      res.clearCookie("accessToken", {
        maxAge: 60 * 1000,
        sameSite: "strict",
        httpOnly: true,
        secure: false,
      });

      res
        .clearCookie("refreshToken", {
          maxAge: 60 * 1000,
          sameSite: "strict",
          httpOnly: true,
          secure: false,
        })
        .redirect("/user/login");
    } catch (err) {
      next(err);
    }
  },
};

export default { output, process };

```

---

## jwt 검증 미들웨어 만들기

이제 로그인 성공 시 토큰을 발급하는 것까지 왼료했습니다.

다음은 클라이언트가 발급받은 토큰을 담아 요청했을 때 로그인 없이 서비스를 제공해보겠습니다.  
(간단하게 로그인 없이 사용자의 닉네임을 반환해보겠습니다.)

router에서 로그인 페이지를 요청할 때 controller로 가기전 jwt_user 미들웨어를 거쳐가도록 구현해보겠습니다.

먼저 라우터 파일입니다.

```js
// routes/user.js
import express from "express";
import ctrl_user from "../controllers/controller_user.js";
import validator_user from "./middleware/validator_user.js";
// 구현할 jwt 검증 미들웨어 파일 import
import authJwt from "./middleware/jwt_user.js";

const Router = express.Router();

// 로그인 페이지 GET 요청 시 미들웨어 거쳐가기
Router.get("/login", authJwt, ctrl_user.output.login);

Router.get("/register", ctrl_user.output.register);
Router.get("/logout", ctrl_user.process.logout);

Router.post("/login", validator_user.login, ctrl_user.process.login);
Router.post("/register", validator_user.register, ctrl_user.process.register);

export default Router;
```

검증할 case 3가지

- `case 1` : **access token**, **refresh token** 없을 때 -> 로그인 페이지로 이동

- `case 2` : **access token 유효** => 서비스 제공
- `case 3` : **access token 만료**, **refresh token 유효** -> access token 재발급 & 서비스 제공
- `case 4` : **access token 만료**, **refresh token 만료** -> 로그인 페이지로 이동

```js
import jwtUtil from "../../utils/jwt.util.js";

const authJwt = async (req, res, next) => {
  try {
    if (req.cookies.accessToken && req.cookies.refreshToken) {
      const accessToken = req.cookies.accessToken;
      const refreshToken = req.cookies.refreshToken;

      // access 토큰 검증 함수
      const accessResult = await jwtUtil.verify(accessToken);

      if (accessResult.success === true) {
        // case 1 :accessToken이 유효한 경우

        //req.user에 토큰 검증으로 얻은 정보를 담아 다음 미들웨어로 보냅니다
        req.user = accessResult;
        next();
      } else {
        // case 2 : accessToken은 만료, refreshToken은 유효한 경우

        // refresh 토큰 검증 함수
        const refreshResult = await jwtUtil.refreshVerify(refreshToken);

        // 검증 성공 시
        if (refreshResult.success === true) {
          // access 토큰 생성
          let newAccessToken = jwtUtil.sign(refreshResult);

          // access 토큰 재발급
          res.cookie("accessToken", newAccessToken, {
            maxAge: 60 * 1000,
            sameSite: "strict",
            httpOnly: true,
            secure: false,
          });

          res.redirect("/user/login");
        }
      }
    } else {
      // case 3 : cookie에 토큰이 존재하지 않은 경우

      // 정보 제공 없이 다음 미들웨어로 보냅니다
      next();
    }
  } catch (err) {
    next(err);
  }
};

export default authJwt;
```

---

## 더 공부할 부분

JWT를 웹에서 저장하기 위해서는 브라우저 저장소에 저장하는 방식과 쿠키에 저장하는 방식을 사용할 수 있습니다.

저장 위치에 따른 보안과, 앱에서 사용하기 위한 방법도 알아보자.

키워드 : XSS, CSRF & CSURF 모듈, request-header
