---
title: 네트워크 - TCP/IP 프로토콜 4계층
author: Psmin
data: 2022-12-17 23:26:53 +0900
categories: [Knowledge]
tags: [TCP/IP, Protocol]
---

# TCP/IP 프로토콜 4계층에 대해 알아보자.

---

## TCP/IP는 무엇일까요?

TCP는 OSI 7 계층 중 **_4 계층 전송 계층_**의 프로토콜이고, IP는 **_3 계층 네트워크 계층_**의 프로토콜입니다.

**_TCP/IP_**는 <u>인터넷 통신 세계에서 가장 많이, 표준으로 사용되고 있는 TCP와 IP 프로토콜을 주축으로 한 프로토콜 집합</u>을 말합니다.

인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고 받을 수 있도록 하는 표준 프로토콜입니다.

**_인터넷 프로토콜 스위트(Internet Protocol Suite)_**라고 부르기도 합니다.

## TCP/IP 4계층

OSI 7 계층과 비교하여 TCP/IP 4 계층을 알아보겠습니다.

![OSI-TCP/IP](/assets/img/osi-tcp-ip.png){: .w-80 .normal}

**TCP/IP 모델**은 OSI 모델의 5~7 계층을 하나의 애플리케이션 게층으로 묶고,  
1,2 계층을 하나의 네트워크 계층으로 묶습니다.

네트워크 통신에 중요한 3 계층의 IP 프로토콜과 4 계층의 TCP 프로토콜을 중심으로 재구성한 프로토콜 집합입니다.

즉, TCP/IP 프로토콜 통신 과정에 집중해 OSI 모델을 좀 더 단순화 시킨 모델입니다.

---

### 계층

- `1 계층 - 네트워크 엑세스 계층 (Network Access Layer)`  
  OSI 모델에서 물리 계층과 데이터 링크 계층을 묶은 계층입니다.

  <kbd>TCP/IP 패킷</kbd>을 네트워크로 전달하거나 받아오는 역할을 합니다.

  - **_대표 프로토콜_** : `Ethernet` 등
  - **_주요 기능_**
    - <kbd>에러 검출</kbd>
    - <kbd>패킷의 프레임화</kbd>

  <br/>

- `2 계층 - 인터넷 계층 (Internet Layer)`  
  OSI 모델에서 네트워크 계층에 해당합니다.

  3 계층인 전송 계층에서 받은 데이터에 IP 패킷 헤더를 붙여 <kbd>IP 패킷</kbd>을 만들어 전송합니다.

  - **_대표 프로토콜_** : `IP`, `ICMP`, `ARP`, `RARP` 등
  - **_주요 기능_**

    - <kbd>Addressing</kbd>
    - <kbd>Packaging</kbd>
    - <kbd>Routing</kbd>

  - **_2 계층에서 사용하는 주소_**
    - MAC 주소  
      물리적인 주소로 장비의 고유 값, 12개의 16진수로 구성 (aa-aa-aa-bb-bb-bb)
    - OUI  
      앞의 6개 (aa-aa-aa)는 IEEE에서 부여한 제조회사 식별 ID
    - 고유번호  
      뒤의 6개 (bb-bb-bb)는 제조회사에서 부여한 장비 식별 번호

  <br/>

- `3 계층 - 전송 계층 (Transport Layer)`  
  OSI 모델에서 전송 계층에 해당합니다.

  IP 주소와 Port 번호를 이용하여 프로세스와 통신합니다.

  - **_대표 프로토콜_** : `TCP`, `UDP` 등

  - **_주요 기능_**

    - <kbd>통신 노드 간의 연결 제어</kbd>
    - <kbd>신뢰성 있는 데이터 전송</kbd>

  - **_3 계층에서 사용하는 주소_**

    - IP 주소  
      WAN에서 통신할 때 사용하는 주소로 인터넷에 연결된 모든 컴퓨터 자원을 구분하는 고유번호입니다.

      - IPv4 주소 (Classful IP 주소)  
        10진수 숫자 8bit씩, 총 32 bit로 구성됩니다. (총 4byte)  
        0.0.0.0 ~ 255.255.255.255

    - 특수한 IP 주소

      - 서브넷 마스크  
        IP 주소에 대한 네트워크 대역을 규정합니다.  
        2진수로 표기된 연속된 1과 뒤에 이어지는 0으로 구성됩니다.

        즉, 1에서 0으로 바뀌는 지점을 네트워크 대역 구분점으로 활용합니다.

      - 게이트웨이 주소  
        외부와 통신할 때 사용하는 네트워크의 출입구입니다.  
        주로 가장 낮거나 가장 높은 ip 주소를 사용합니다.

    3 계층에서는 다음 3가지를 활용해 통신합니다.

    - 추가

      - 공인 IP
      - 사설 IP
      - NAT

<br/>

- `4 계층 - 응용 계층 (Application Layer)`  
   OSI 모델에서 세션 계층, 표현 계층, 응용 계층에 해당합니다.

  프로그램과 직접 상호작용하는 계층으로 데이터를 처음 받거나 보내는 곳입니다.

  즉, MAC 주소와 IP 주소를 이용해 상대방의 주소를 찾아낸 후 해당 프로그램을 찾아가는 역할을 수행합니다.

  - **_대표 프로토콜_** : `HTTP`, `FTP` 등

  - **_주요 기능_**

    - <kbd>사용자가 접근할 수 있는 인터페이스 제공</kbd>

  - **_4 계층에서 사용하는 주소_**

    - Port 번호
      특정 프로그램이 사용하는 번호로 Port 번호 하나당 프로그램 하나만 사용합니다.
      0 ~ 65535 (2byte)까지 사용 가능

    - Port 번호 분류 (3 가지)

      1. Well-Known Port (System Port) , 0 ~ 1024  
         FTP : 20 or 21, SSH : 22, TELNET : 23, DNS : 53,  
         DHCP : 67 or 68, HTTP : 80, HTTPS : 443 등

      2. Registered Port (User Port), 1024 ~ 49151  
         많이 알려진 서비스들이 등록되어 있는 Port
         Oracle DB 서버 : 1521, Mysql 서버 : 3306 등

      3. Private Port (Dynamic Port) , 49152 ~ 65535
         사용자들이 사용하는 Port입니다.

<br/>

{: .prompt-info}

> 그럼 여기서 프로토콜이란 무엇일까요?

---

## Protocol 프로토콜

프로토콜은 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화한 통신 규약을 말합니다.

인터넷을 통해서 **_이메일_**을 보낼 때는 `SMTP (Simple Mail Transfer Protocol)`이 규정되어 있고 전 세계의 메일 서버가 이를 따르기 때문에 어디서든 메일을 주고 받을 수 있습니다.

또한, 가장 많이 사용되는 **_월드 와이드 웹(WWW)_**은 `HTTP (HyperText Transfer Protocol)`이 규정되어 있어 웹 서버와 웹 브라우저가 이를 따르기 때문에 전 세계 어디서든 웹을 이용할 수 있습니다.

---

### 기본 요소

- 구문 (Syntax) : 전송할 데이터 형식, 부호화, 신호 레벨 등 구성
- 의미 (Senmantics) : 두 기기 간의 효울적이고 정확한 정보 전송을 위한 **_협조 사항_**과 오류 관리를 위한 **_제어 정보_**
- 시간 (Timing) : 두 기기 간의 통신 속도, 메세지의 순서 제어 등을 규정

---

### 기능

- 단편화와 재결합
  > 단편화 : 송신 측에서 전송할 데이터를 전송에 알맞은 일정 크기의 작은 블록으로 자르는 작업  
  > 재결합 : 수신 측에서 단편화된 블록을 원래의 데이터로 모으는 작업
- 캡슐화
  > 캡슐화 : 단편화된 데이터에 송수신 주소, 오류 검출 코드 등 여러 정보를 부가하는 것
- 흐름 제어
- 오류 제어
- 순서 제어 등

---

### 패킷 Packet

패킷이란 네트워크 상에서 전달되는 데이터로 전달하는 데이터의 형식화된 블록을 말합니다.  
즉, 네트워크를 통해 전송하기 쉽도록 분할된 데이터 전송 단위입니다.

분할되어 동시다발적으로 데이터를 주고 받음으로써 에러에 따른 재전송이나 송수신 시 걸리는 시간 등의 문제를 해결할 수 있습니다.

- 패킷의 캡슐화, 역캡슐화

  - `캡슐화`  
    데이터 송신 시, 데이터는 TCP/IP 4 계층의 상위 계층에서 하위 계층으로 이동하며, 계층을 이동할 때마다 필요한 정보를 헤더에 추가해 패킷으로 만드는 과정을 말합니다.

  ![encapsulation](/assets/img/encapsulation.png){: .w-80 .normal}

  - `역캡슐화`  
    데이터 수신 시, 데이터는 TCP/IP 4 계층의 하위 계층에서 상위 계층으로 이동하며, 헤더를 읽고 처리한 후, 헤더를 제거하는 과정으로 받은 패킷을 확인하는 과정을 말합니다.

  ![decapsulation](/assets/img/decapsulation.png){: .w-80 .normal}

- 프로토콜 데이터 단위 (Protocol Data Unit, PDU)  
  PDU는 계층에서 처리하는 데이터 단위를 말하며, 추가된 Header와 상위 계층의 데이터가 합쳐진 한 계층의 전체 데이터입니다.

  제어 정보를 포함하는 <kbd>헤더(Header)</kbd>와 데이터 자체인 <kbd>페이로드(Payload)</kbd>로 구성됩니다.

  > 헤더(Header)를 PCI(Protocol Control Information)로 페이로드(Payload)을 SDU(Service Data Unit)로 명칭하기도 합니다.  
  > 즉, PDU = PCI + SDU

  PDU는 각 계층을 지나오면서 데이터 자체는 동일하지만 헤더 정보가 추가되면서 명칭이 달라집니다.

  ![PDU](/assets/img/pdu.png){: .w-80 .normal}

  간단하게 정리하자면

  - 4 계층 : <kbd>Segment</kbd>
  - 3 계층 : <kbd>Packet</kbd>
  - 2 계층 : <kbd>Frame</kbd>
  - 1 계층 : <kbd>Bit</kbd>

---

## 계층별 주요 프로토콜

### Ethernet Protocol (OSI - 2 계층, TCP/IP - 1 계층)

이더넷 (Ethernet)은 사무실이나 가정에서 많이 사용하는 LAN에서 많이 활용되는 기술입니다.

네트워크에 연결된 각 기기들이 MAC 주소를 이용해 상호간에 데이터를 주고 받을 수 있도록 만들어졌습니다.

- Ethernet Frame의 구성요소  
  ![Ethernet](/assets/img/ethernet.png){: .w-80 .normal}

  - **_Preamble (7byte)_**  
    첫 번째 필드로 0 과 1이 반복되는 7byte로 수신 시스템에게 프레임이 도착하는 것을 알려줍니다.  
    물리계층에서 전송된 비트패턴으로 송신자와 수신자의 동기를 맞추는데 사용됩니다.  
    7byte 크기이고, 항상 10101010... 으로 설정됩니다.

  - **_SFD(Start of Frame Delimeter) (1byte)_**  
    물리계층이 끝나고 이제부터는 Ethernet 헤더라고 알려주는 신호 역할을 합니다.  
    항상 1010101011이며 패킷 캡처 밖 영역입니다.
    마지막 두 비트 11은 수신자에게 다음 필드가 목적지 주소라는 것을 알려준다.

  - **_Destination address (6byte)_**  
    Frame을 수신하는 목적지의 MAC 주소입니다.

  - **_Source address (6byte)_**  
    Frame을 송신하는 송신지의 MAC 주소입니다.

  - **_Ethernet Type (2byte)_**  
    해당 프레임의 상위 계층 프로토콜 정보입니다.  
    즉, 캡슐화 된 상위 프로토콜을 알려줍니다. (0x0800 = IPv4, 0x0806 = ARP)

  - **_Data_**  
    상위 계층으로 부터 전달받은 데이터가 담겨있습니다.  
    최소 46byte ~ 최대 1500byte 크기를 가진다.

  - **_Padding_**  
    만약 Data Length가 46byte보다 작다면 46byte 크기를 임의로 채워주는 역할을 한다. (끝에 padding이 0으로 채워집니다.)

  - **_FCS(CRC) (4byte)_**  
    Frame의 오류를 확인하는 필드입니다.  
    Destination Addr + Source Addr + Length + Data 영역을 계산해서 에러를 판별합니다. 송신측의 데이터로부터 다항식에 의해 추출된 결과를 FCS에 붙여서 보내면 수신측에서는 동일한 방법으로 추출한 결과와 일치하는지 확인을 합니다.

---

### ARP 프로토콜 (OSI - 3 계층, TCP/IP - 2 계층)

ARP 프로토콜은 같은 네트워크 대역에서 통신을 하기위해 필요한 MAC 주소를 IP 주소를 통해 알아오는 프로토콜입니다.

- ARP 프로토콜의 구성 요소  
  ![ARP-Protocol](/assets/img/arp-protocol.png){: .w-80 .normal}

  - **_Hardware type (4byte)_**  
    하드웨어 주소(MAC) 유형을 나타내며, 가장 많이 사용되는 Ethernet의 경우 0x0001 으로 설정됩니다.

  - **_Protocol type (4byte)_**  
    매핑 대상인 3계층에서 쓰일 프로토콜 주소의 유형을 나타내며, 가장 많이 사용되는 IPv4의 경우 0x0800 으로 설정됩니다.

  - **_Hardware Address Length (2byte)_**  
    하드웨어 주소(MAC 주소)의 길이를 byte로 나타내며, Ethernet 상에서 6으로 설정됩니다.

  - **_Protocol Address Length (2byte)_**  
    프로토콜 주소의 길이를 byte로 나타내며, IPv4의 경우 4로 설정됩니다.

  - **_Opcode_**  
     ARP 패킷이 요청(Request) 또는 응답(Reply)에 따라 값이 바뀌게 되고 요청의 경우 1, 응답의 경우 2가 설정됩니다.
    (RARP의 요청은 3, RARP의 응답은 4가 설정됩니다.)

    > RARP는 ARP 프로토콜의 반대 개념으로 MAC 주소를 통해 IP 주소를 알아오는 프로토콜입니다.

  - **_Source Hardware Address (6byte)_**  
    출발지 MAC 주소를 나타내는 필드입니다.

  - **_Source Protocol Address (4byte)_**  
    출발지 IP 주소를 나타내는 필드입니다.

  - **_Destination Hardware Address (6byte)_**  
    목적지 MAC 주소를 나타내는 필드입니다.  
    알아내는 것이 목표이기 때문에 요청인 경우 송신 측은 0으로 설정됩니다.

  - **_Destination Protocol Address (4byte)_**  
    목적지 IP 주소를 나타내는 필드입니다.

---

### IPv4 프로토콜 (OSI - 3 계층, TCP/IP - 2 계층)

패킷 교환 네트워크 상에서 데이터를 교환하기 위한 프로토콜입니다.  
인터넷 프로토콜의 4번째 판이며, 전 세계적으로 사용된 첫 번째 인터넷 프로토콜입니다.

중복된 패킷을 전달하거나 패킷의 순서가 잘못 전달되는 등 데이터가 정확하게 전달되는 것을 보장하지는 않습니다. 이는 4 계층의 TCP 프로토콜에서 보장합니다.

- IPv4 프로토콜의 구성 요소  
  ![IPv4-Protocol](/assets/img/ipv4-protocol.png){: .w-80 .normal}

  - **_Version (4bit)_**  
    IP 프로토콜 버전 필드입니다.  
    IPv6은 구조 자체가 달라 IPv4를 의미하는 4bit(0100)가 고정적으로 사용됩니다.

  - **_IHL(Header Length) (4bit)_**  
    실제 헤더 길이 필드로 Protocol의 총 길이 필드입니다.  
    기본적으로 20byte에 option당 4byte가 추가 되며, 1byte이므로 최종 값을 4로 나눈 2진수 값이 들어갑니다.

  - **_TOS(Type of Service) (1byte)_**  
    서비스의 형식을 나타내는 필드로 데이터의 중요도를 나타내는 파트로 예전엔 사용했지만 현재는 사용되지 않고 0으로 고정됩니다.

  - **_Total Length (2byte)_**  
    Header에 데이터(Payload)까지 합쳐진 총 길이 필드입니다.

  - **_Identification + IP Flags + Fragment Offset (4byte)_**
    하나의 세트로 데이터를 분할해서 전송할 때 사용합니다.

    - Identification (2byte)
      원래 하나였던 데이터에게는 같은 값을 부여해 구분합니다.

    - IP FLags (3bit)

      - x (1bit) : 예약 필드, 사용하지 않음
      - D (1bit) : 패킷을 조각화하지 않으면 1  
        (1로 설정 시 최대 길이를 넘어가는 패킷을 전송하지 않습니다.)
      - M (1bit) : 패킷을 조각화할 시 1  
        (분할된 패킷을 보낼 때 뒤에 다른 패킷이 더 있다는걸 알려주는 필드입니다.)

    - Fragment Offset (13bit)  
      분할된 패킷을 합치는 순서를 의미합니다.  
      (데이터의 시작 부분으로부터 얼마나 떨어져 있는지 byte를 8로 나눈 값이 들어갑니다.)

  - **_TTL(Time to Live) (1byte)_**  
    생명 주기로 무한 루프와 같은 패킷 전송 시 발생할 수 있는 오류를 대비합니다.

    최대 전달 횟수를 입력해 라우터 등의 장비를 거칠 때마다 1씩 줄어드어 0이되면 소멸합니다.

  - **_Protocol (1byte)_**  
    상위 프로토콜이 무엇인 지 알려주는 필드입니다.  
    (ICMP : 01, TCP : 06, UDP : 11 등)

  - **_Header CheckSum (2byte)_**  
    현재 헤더에 오류가 있는 지 확인합니다.

  - **_Source Address (4byte)_**  
    출발지의 IP 주소 필드입니다.

  - **_Destination Address (4byte)_**  
    도착지의 IP 주소 필드입니다.

  - **_Option (개당 4byte)_**  
     추가적으로 붙을 수도, 붙지 않을 수도 있는 옵션 필드입니다.  
     개당 4byte로 최대 10개까지 추가 가능합니다.  
     (Variable length, not common 등)

- IPv4 조각화  
  큰 IP 패킷이 적은 MTU (Maximum Transmission Unit)을 갖는 링크를 통해 전송될 때, 여러 개의 작은 패킷으로 조각화되어 전송됩니다.

  > MTU : 최대 정송 단위

  - 패킷이 전달되는 과정에서 라우터마다 적합한 Frame으로 변환 필요
  - 재조립은 대부분 최종 목적지에서만 가능
  - IPv4에서는 중간 라우터에서도 조각화가 가능, IPv6는 불가능
  - 마지막 패킷에만 ICMP 프로토콜 Encapsulation
  - MTU 통과 후 Ethernet 프로토콜 Encapsulation

  ![fragmentation](/assets/img/fragmentation-01.png){: .w-80 .normal}
  ![fragmentation](/assets/img/fragmentation-02.png){: .w-60 .normal}

---

### ICMP 프로토콜 (OSI - 3 계층, TCP/IP - 2 계층)

네트워크 컴퓨터 위의 운영체제에게 오류 메세지를 전송받는데 주로 사용됩니다.

- ICMP 프로토콜의 구성 요소  
  ![ICMP-Protocol](/assets/img/icmp-protocol.png){: .w-80 .normal}

  - **_Type (1byte)_**  
    메세지 타입 선택 필드로 0 ~ 30번 까지 다양하게 사용됩니다.  
    (0 : 정상 응답, 8 : 요청, 3 : 경로 문제로 도착 불가능, 11 : 요청 시간 만료, 5 : 리 다이렉트 등)

  - **_Code (1byte)_**  
    추가적인 메세지 정보 필드입니다.

  - **_CheckSum (2byte)_**  
    헤더의 오류 확인

---

### UDP 프로토콜 (OSI - 4 계층, TCP/IP - 3 계층)

비 연결형 서비스를 지원하는 프로토콜입니다.  
인터넷 상에서 서로 정보를 주고 받을 때 신호 절차를 거치지 않고, 보내는 쪽에서 일방적으로 데이터를 전달합니다.

- 단순하지만 속도가 빠르다.
- 서비스의 신뢰성이 낮다.
- Datagram의 도착 순서 변경, 중복, 누락의 문제가 발생할 수 있습니다.
- 대표적으로 DNS 서버가 사용합니다.

- UDP 프로토콜의 구성 요소
  ![UDP-Protocol](/assets/img/udp-protocol.png){: .w-80 .normal}

  - **_Source Port (2byte)_**  
    출발지의 Port 번호입니다.

  - **_Destination Port (2byte)_**  
    도착지의 Port 번호입니다.

  - **_Length (2byte)_**  
    UDP 헤더와 Data를 포함한 총 길이 (byte 단위)

  - **_CheckSum (2byte)_**  
    Data 손상 확인

---

### TCP 프로토콜 (OSI - 4 계층, TCP/IP - 3 계층)

연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용합니다.  
인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함꼐 사용합니다.

- 신뢰성 있는 데이터 전송
- 데이터의 전송 순서 보장
- 느린 속도
- 패킷 추적 및 관리

- TCP 프로토콜의 구성 요소
  ![TCP-Protocol](/assets/img/tcp-protocol.png){: .w-80 .normal}

  - **_Source Port (2byte)_**  
    출발지의 Port 번호입니다.

  - **_Destination Port (2byte)_**  
    도착지의 Port 번호입니다.

  - **_Seq (Sequence Number, 4byte)_**  
    처음엔 랜덤한 값을 부여합니다. 동기화 후엔 처음 값 + 1이 부여됩니다.
    (신뢰성(\*3Way Handshake) 및 흐름제어(sliding Window) 기능을 제공)

  - **_Ack (Acknowledgment Number, 4byte)_**  
    수신하기를 기대하는 다음 byte 번호

  - **_Offset (4bit)_**  
    헤더의 길이 필드입니다. 전체 길이를 4로 나눈 후 2진수로 표기합니다.

  - **_Reserved (4bit)_**  
    예약 필드입니다. 현재는 사용하지 않습니다.

  - **_TCP Flags (1byte)_**
    현재 패킷의 종류를 구분합니다.

    - U (URG) : 긴급 비트, 우선순위가 높은 데이터를 포함한 패킷
    - A (ACK) : 승인 비트, 응답을 해줄 때 사용하는 패킷
    - P (Push) : 밀어넣기 비트, TCP 버퍼가 쌓이기 전에 데이터를 전송하는 패킷
    - R (RST) : 초기화 비트, 데이터 교환에 문제 발생으로 연결을 초기화하는 패킷
    - S (SYN) : 동기화 비트, Seq 번호를 동기화하고 연결 수립을 요청하는 패킷
    - F (FIN) : 종료 비트, 서버와 클라이언트의 연결을 종료하겠다는 패킷

  - **_Window (2byte)_**  
    남은 버퍼의 크기를 알려줍니다. 즉, "얼마만큼 더 보내"를 의미합니다.

  - **_CheckSum (2byte)_**  
    에러 검사 필드입니다.

  - **_Urgent Pointer (2byte)_**
    어디서부터 긴급 값인지 알려주는 플래그입니다. (TCP Flags의 U와 세트)

- `TCP의 통신 과정`

  1. 연결 수립 과정  
     TCP를 이용한 데이터 통신 시 가장 먼저 수행됩니다.

     - 순서
       1. Client가 Server에 요청 패킷을 보냅니다. (SYN)
       2. Server가 Client의 요청 받아들이는 패킷과 요청 패킷을 보냅니다. (ACK, SYN)
       3. Client가 이를 최종 수락하는 패킷을 보냅니다. (ACK)
          => <kbd>3 Way HandShake</kbd>

  2. 데이터 송 수신 과정  
     연결이 수립된 후 이어지는 과정으로 Seq와 Ack를 이어갑니다.

  - 페이로드를 포함한 데이터 송 수신 시 지켜야할 규칙
    1. 송신 측에서는 다시 보낼 때 Seq와 Ack는 동일합니다.
    2. 수신 측의 Seq는 송신 측에서 보낸 Ack로 바뀝니다.
    3. 수신 측의 Ack는 송신 측에서 보낸 Seq + 데이터의 크기로 바뀝니다.

  3. 연결 해제 과정

  - 순서
    1. Client는 응답을 주고 연결을 끊기 위해 종료 패킷을 보냅니다. (FIN)
    2. Server는 Client의 요청을 받아들이는 패킷을 보냅니다. (ACK)
    3. Server는 사용한 소켓을 정리하며 통신을 끝내는 종료 패킷을 보냅니다. (FIN)
    4. Client는 서버 패킷에 대한 응답으로 요청을 받아들이는 패킷을 보냅니다. (ACK)
       => <kbd>4 Way HandShake</kbd>

  ![TCP-connect](/assets/img/tcp-connect.png){: .w-80 .normal}

---

### HTTP 프로토콜 (OSI - 7 계층, TCP/IP - 4 계층)

---

## TCP/IP 동작 순서

![TCP/IP-Total](/assets/img/tcp-ip-total.png){: .w-80 .normal}

- 송신 측 브라우저에서 주소창에 특정 주소를 입력합니다.
- 보낼 패킷의 HTTP 헤더가 HTTP Request를 통해 채워집니다.
- 보낼 패킷의 IP 헤더를 채우기 위해 DNS 서버에서 도메인의 IP 주소를 응답 받습니다.
- 보낸 패킷의 IP 헤더가 채워지고 TCP 헤더를 채우기 위해, 클라이언트가 웹 서버와 TCP 연결합니다. (3 Way HandShake)
- 마지막으로 MAC 주소(모를시 ARP 헤더를 추가해 알아냅니다.)와 Ethernet 헤더를 추가해 패킷을 전송합니다.
- 수신측 서버는 데이터를 받아들여 헤더를 열어보며 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달합니다.
- 수신측 애플리케이션 계층에 도달하게 되면 클라이언트가 발신했던 HTTP 리퀘스트를 수신할 수 있습니다.
- 클라이언트는 응답 받은 HTML을 브라우저에 띄웁니다.
- 클라이언트와 웹 서버간 TCP 연결을 종료합니다. (4 Way HandShake)

---

## 참조

- <https://blackrimslifestory.blogspot.com/2018/02/ethernet-frame.html>
- <https://lxxyeon.tistory.com/155>
- <https://hwannny.tistory.com/117>
- <https://wooono.tistory.com/507>
- <https://nordvpn.com/ko/blog/tcp-ip-protocol/>
- <https://nirsa.tistory.com/28>
- <https://nirsa.tistory.com/29>
- <https://velog.io/@rlacksals96/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3way-handshake>
- <https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-TCP-IP-%EC%A0%95%EB%A6%AC-%F0%9F%91%AB%F0%9F%8F%BD-TCP-IP-4%EA%B3%84%EC%B8%B5>
