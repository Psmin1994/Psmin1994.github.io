---
title: 영화 정보 제공 사이트 - 02
author: Psmin
data: 2024-02-09 22:44:37 +0900
categories: [Project, Movie Story]
tags: [Scraping]
---

# DB에 데이터를 추가해보자.

---

## 공공 데이터 활용

첫 번째 방법은 공공 데이터를 제공받을 수 있는 OPEN API를 활용해보는 것이였습니다.

영화진흥위원회의 오픈 API를 활용해보겠습니다.

> 사이트 링크 : [영화진흥위원화](https://www.kobis.or.kr/kobisopenapi/homepg/apiservice/searchServiceInfo.do?serviceId=searchMovieList)

- **첫번째 Get 요청 (일별 박스오피스 API)**

  `날짜(targetDt)`를 parameter로 해당 날짜의 상영 영화들의 대한 정보를 가져옵니다.

  > 사용할 데이터 : 개봉일, 누적관객수

- **두번째 Get 요청 (영화 상세 정보 API)**

  `영화 코드(movieCd)`를 parameter로 영화에 상세 정보 데이터를 가져옵니다.

  > 사용할 데이터 : 영화제목 한/영, 장르, 제작국가, 상영시간, 영화감독, 배우

- **요청 코드**

  ```js
  // 영화진흥위원회 공공 데이터 추출
  import axios from "axios";

  try {
    // 일별 박스오피스 API 요청 주소
    let url =
      "http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json";

    let dt = new Date();

    // 가져올 날짜 설정
    let today = `${dt.getFullYear()}${
      dt.getMonth() < 9 ? "0" + (dt.getMonth() + 1) : dt.getMonth() + 1
    }${dt.getDate() - 7}`;

    let res = await axios({
      method: "get",
      url: url,
      params: {
        key: "332ba9ce1cb2f258e6e32ab988458a6c",
        // parameter 로 날짜 지정
        targetDt: today,
      },
    }); // axios(url[, config]) 형태

    // kobis의 일별 박스오피스 Open API로 가져온 설정 날짜의 상영 영화 정보 배열
    let movieList = res.data.boxOfficeResult.dailyBoxOfficeList;

    console.log(movieList[0]);

    // 가져온 데이터에서 영화 상세 정보 데이터를 얻기 위해 영화 코드(movieCd)를 추출
    let movieCd = movieList[0].movieCd;

    // 영화 상세 정보 API 요청 주소
    url = `http://www.kobis.or.kr/kobisopenapi/webservice/rest/movie/searchMovieInfo.json`;

    res = await axios({
      method: "get",
      url: url,
      params: {
        key: "332ba9ce1cb2f258e6e32ab988458a6c",
        // 가져올 영화의 영화 코드 지정
        movieCd,
      },
    }); // axios(url[, config]) 형태

    console.log(res.data.movieInfoResult.movieInfo);
  } catch (err) {
    console.log(err);
  }
  ```

- **응답 데이터**

  ```js
  // 첫번째 응답
  {
    rnum: '1',
    rank: '1',
    rankInten: '0',
    rankOldAndNew: 'OLD',
    movieCd: '20236180', // 영화코드
    movieNm: '웡카',
    openDt: '2024-01-31', // 개봉일 (YYYY-MM-DD)
    salesAmt: '2288686938',
    salesShare: '54.6',
    salesInten: '1358999415',
    salesChange: '146.2',
    salesAcc: '5501692614',
    audiCnt: '226091',
    audiInten: '134065',
    audiChange: '145.7',
    audiAcc: '578105', // 누적관객수
    scrnCnt: '1751',
    showCnt: '8082'
  }

  // 두번째 응답
  {
    movieCd: '20236180',
    movieNm: '웡카',
    movieNmEn: 'Wonka',
    movieNmOg: '',
    showTm: '116',
    prdtYear: '2023',
    openDt: '20240131',
    prdtStatNm: '개봉',
    typeNm: '장편',
    nations: [ { nationNm: '미국' } ],
    genres: [ { genreNm: '판타지' }, { genreNm: '드라마' } ],
    directors: [ { peopleNm: '폴 킹', peopleNmEn: 'Paul King' } ],
    actors: [
      {
        peopleNm: '티모시 샬라메',
        peopleNmEn: 'Timothee Chalamet',
        cast: '',
        castEn: ''
      },
      {
        peopleNm: '칼라 레인',
        peopleNmEn: 'Calah Lane',
        cast: '',
        castEn: ''
      },
      {
        peopleNm: '올리비아 콜맨',
        peopleNmEn: 'Olivia Colman',
        cast: '',
        castEn: ''
      },
      {
        peopleNm: '톰 데이비스',
        peopleNmEn: 'Tom Davis',
        cast: '',
        castEn: ''
      },
      {
        peopleNm: '휴 그랜트',
        peopleNmEn: 'Hugh Grant',
        cast: '',
        castEn: ''
      },
      {
        peopleNm: '샐리 호킨스',
        peopleNmEn: 'Sally Hawkins',
        cast: '',
        castEn: ''
      }
    ],

    ...

  }
  ```

  - **개봉일** : `openDt (String)`
  - **누적관객수** : `audiAcc (String)`
  - **영화제목 한/영** : `movieNm (String)` / `movieNmEn (String)`
  - **장르** : `genres (Array)`
  - **제작국가** : `nations (Array)`
  - **상영시간** : `showTm (String)`
  - **영화감독** : `directors (Array)`
  - **배우** : `actors (Array)`

---

### 문제점

1. 현재 날짜에 대한 데이터를 제공하지않습니다.

2. 줄거리, 포스터사진 등 원하는 데이터를 따로 구해야한다.

3. OPEN API를 사용하기 위해 필요한 Key를 주기적으로 갱신해주어야한다.

이러한 단점으로 현재 개봉 중인 영화를 실시간으로 제공하려는 서비스에는 맞지 않습니다.

---

## 웹 스크래핑 (Scraping)

두 번째 방법으로 puppeteer를 사용한 웹 스크래핑을 활용해보겠습니다.

[네이버](https://m.naver.com/)에서 현재 상영 영화에 대한 데이터를 추출해보겠습니다.

---

### getList

네이버 홈페이지에 **현재 상영 영화**를 검색해서 나온 데이터에서 제목만 추출해 배열로 반환합니다.

```js
import puppeteer from "puppeteer";

var getList = async () => {
  try {
    let result = [];

    // 페이지 별로 영화 리스트의 모든 영화에 대해 영화제목 데이터를 result에 push
    const crawlList = async () => {
      await page.waitForSelector(
        "div.cm_content_wrap > div > div > div > div.card_content > div.card_area > div"
      );

      let movieList = await page.$$(
        "div.cm_content_wrap > div > div > div > div.card_content._result_area > div.card_area._panel > div"
      );

      for (let movie of movieList) {
        let movieName = await movie.$eval(
          "div.data_area > div > div.title > div > a",
          (el) => {
            return el.text;
          }
        );

        result.push(movieName);
      }
    };

    const browser = await puppeteer.launch({
      headless: true,
    });

    const page = await browser.newPage();

    await page.goto("https://www.naver.com/");

    await page.click("#query");

    await page.type("#query", `현재 상영 영화`);

    await page.click("#sform > fieldset > button");

    await page.waitForSelector(
      "div.card_content._result_area > div.cm_paging_area._page > div > span > span._total"
    );

    const pageNum = await page.$eval(
      "div.card_content._result_area > div.cm_paging_area._page > div > span > span._total",
      (el) => {
        return el.textContent;
      }
    );

    for (let i = 1; i < pageNum; i++) {
      await crawlList();

      await page.click(
        "div.card_content._result_area > div.cm_paging_area._page > div > a.pg_next.on._next"
      );
    }

    await crawlList();

    await browser.close();

    return result;
  } catch (e) {
    console.error(e);
  }
};

export default getList;
```

---

### getMovie

`getList` 에서 추출한 영화 제목 배열 데이터를 받아 **영화 정보**를 검색합니다.

```js
import puppeteer from "puppeteer";
import getImgUrl from "./getImgUrl.js";
import movieStorage from "./model/movieInsert.model.js";

var getMovie = async (movieList) => {
  try {
    // 옵션으로 headless모드를 끌 수 있다.
    const browser = await puppeteer.launch({
      headless: true,
    });

    const page = await browser.newPage();

    for (let movieName of movieList) {
      await page.goto("https://www.naver.com/");

      await page.click("#query");

      await page.type("#query", `영화 ${movieName} 정보`);

      // 영화 기본 정보 페이지로 이동
      await page.click("#sform > fieldset > button");

      await page.waitForSelector("div.detail_info > dl > div");

      let movieData = {};
      let genreData = [];

      // 영화 데이터 추출
      movieData.movie_nm = await page.$eval(
        "div.cm_top_wrap > div.title_area > h2 > span.area_text_title > strong",
        (el) => {
          return el.textContent;
        }
      );

      movieData.movie_nm_en = await page.$eval(
        "div.cm_top_wrap > div.title_area > div > span:nth-child(3)",
        (el) => {
          return el.textContent;
        }
      );

      let infoList = await page.$$("div.detail_info > dl > div");

      for (let node of infoList) {
        const key = await node.$eval("dt", (element) => {
          return element.textContent;
        });

        const value = await node.$eval("dd", (element) => {
          return element.textContent;
        });

        switch (key) {
          case "개봉":
            movieData.open_date = value.slice(0, -1).replaceAll(".", "-");
            break;

          // case "등급":
          // movieData.filmRate = value;
          // break;

          // 장르 데이터는 따로 저장
          case "장르":
            let tmp = value.split(", " || "/");

            for (let genre of tmp) genreData.push(genre);
            break;
          case "국가":
            movieData.nation = value;
            break;
          case "러닝타임":
            movieData.showtime = value.replace("분", "") * 1;
            break;
          default:
            break;
        }
      }

      await page.waitForSelector(
        "div.cm_content_wrap > div.cm_content_area > div > div.intro_box._content > p"
      );

      movieData.summary = await page.$eval(
        "div.cm_content_wrap > div.cm_content_area > div > div.intro_box._content > p",
        (el) => {
          return el.textContent;
        }
      );

      // 포토 페이지로 이동
      await page.click(
        "div.cm_content_wrap > div.cm_content_area > div > div.detail_info > a"
      );

      await page.waitForSelector(
        "div.area_card._image_base_poster > div > div.movie_photo_list._list > div > ul > li:nth-child(1) > a > img"
      );

      let posterUrl = await page.$eval(
        "div.area_card._image_base_poster > div > div.movie_photo_list > div > ul > li:nth-child(1) > a > img",
        (el) => {
          return el.src;
        }
      );

      movieData.movie_poster = await getImgUrl(
        posterUrl,
        movieData.movie_nm_en,
        `${movieData.movie_nm_en}/poster`
      );

      // 영화 스틸 컷도 추출 (추가로 테이블 명세서 작성 필요)
      // 영화당 여러 장이므로 따로 테이블 만들어서 저장 (장르 테이블처럼)
      await page.waitForSelector(
        "div.area_card._image_base_stillcut > div > div.movie_photo_list._list > div > ul > li"
      );

      let photoList = await page.$$(
        "div.area_card._image_base_stillcut > div > div.movie_photo_list._list > div > ul > li"
      );

      if (photoList.length > 6) photoList.length = 6;

      let photoData = [];

      for (let i = 0; i < photoList.length; i++) {
        let imgUrl = await photoList[i].$eval("a > img", (el) => {
          return el.src;
        });

        let newImgUrl = await getImgUrl(
          imgUrl,
          `${movieData.movie_nm_en}_${i}`,
          `${movieData.movie_nm_en}/stillcut`
        );

        photoData.push(newImgUrl);
      }

      console.log(movieData);
      console.log(genreData);
      console.log(photoData);
    }

    // 브라우저를 종료한다.
    await browser.close();
  } catch (e) {
    console.error(e);

    return e;
  }
};

export default getMovie;
```
