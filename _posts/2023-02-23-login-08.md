---
title: 로그인 페이지 만들기 - jsonwebtoken(JWT)
author: Psmin
data: 2023-03-04 17:38:23 +0900
categories: [Project, Login Page]
tags: [jsonwebtoken, JWT]
---

# JWT를 이용해 로그인 기능을 구현해보자.

---

## 구현 로직

Access Token과 Refresh Token을 모두 이용한 서버 인증 방식으로 구현해보겠습니다.

![access-refresh-jwt](/assets/img/access-refresh-jwt.png){: .w-80 .normal}

1. 사용자가 로그인을 시도합니다.
2. 서버는 사용자를 DB를 통해 조회하고 사용자 확인에 성공하면 AccessToken, RefreshToken을 발급하고 응답합니다.
3. 다음 요청부터 사용자는 로그인이 필요한 서비스에는 발급받은 AccessToken을 담아 요청합니다.
4. AccessToken이 유효하다면 DB조회 없이 서버는 바로 서비스를 제공합니다.
5. AccessToken이 만료됐다면 RefreshToken을 통해 AccessToken을 재발급합니다.
6. RefreshToken도 만료됐다면 다시 로그인이 필요함을 알려줍니다.

---

## express + JWT

기존의 session + Cookie 방식에서 jwt + cookie 방식으로 바꿔보겠습니다.

사용할 모듈

- jsonwebtoken 모듈
- redis 모듈

- redis는 redis 클라우드 서비스인 redisLabs을 이용하겠습니다.

---

## app.js 수정하기

기존의 session 관련 내용들은 주석 처리 해주겠습니다.

```js
import express from "express";
import path from "path";
import dotenv from "dotenv";
dotenv.config();

import bodyParser from "body-parser";
import cookieParser from "cookie-parser";
import morganMiddleware from "./src/middleware/morgan.js";
import userRouter from "./src/routes/route_user.js";
import passport from "passport";
import passportConfig from "./src/config/passport/Strategy.js"; // JWT 방식 구현
// import sessionMiddleware from "./src/middleware/session.js"; // session 방식 구현
// import passportConfig from "./src/config/passport/index.js"; // session 방식 구현

...

// passport
// app.use(sessionMiddleware); // session 방식 구현
app.use(passport.initialize());
// app.use(passport.session()); // session 방식 구현
passportConfig();

...

// 3000 포트로 서버 오픈
app.listen(3000, () => {
  console.log("express server on port 3000");
});

```

---

## jwt-util.js 만들기

Token 생성, 검증 함수를 만들어 utils 폴더에 담아 관리하겠습니다.

- AccessToken은 짧은 만료기간으로 설정하고 refresh는 긴 만료기간을 설정합니다.
- Refresh Token과 Access Token을 모두 발급한 후, Refresh Token만 redis에 저장한다.

```js
import jwt from "jsonwebtoken";
import redisClient from "../config/redis.js";

const accessTokenSecret = process.env.ACCESS_TOKEN_SECRET;
const refreshTokenSecret = process.env.REFRESH_TOKEN_SECRET;

export default {
  // AccessToken 생성 함수
  sign: (user) => {
    return jwt.sign(
      {
        id: user.id,
        nickname: user.nickname,
      },
      accessTokenSecret,
      {
        expiresIn: "30m", // 유효기간
      }
    );
  },

  // AccessToken 검증 함수
  verify: async (accessToken) => {
    try {
      const decoded = await jwt.verify(accessToken, accessTokenSecret);

      return {
        success: true,
        id: decoded.id,
        nickname: decoded.nickname,
      };
    } catch (err) {
      return { success: false, msg: err };
    }
  },

  // refreshToken 생성 함수
  refreshSign: (user) => {
    return jwt.sign(
      {
        id: user.id,
        nickname: user.nickname,
      },
      refreshTokenSecret,
      {
        expiresIn: "14d", // 유효기간
      }
    );
  },

  // refreshToken 검증 함수
  refreshVerify: async (refreshToken) => {
    try {
      const user = await jwt.verify(refreshToken, refreshTokenSecret);

      const data = await redisClient.get(user.id); // redis에서 refreshToken 가져오기

      if (refreshToken === data) {
        return {
          success: true,
          id: user.id,
          nickname: user.nickname,
        };
      } else {
        throw false;
      }
    } catch (err) {
      return { success: false, msg: err };
    }
  },
};
```

---

## redis를 사용하는 이유

JWT 하나로는 토큰이 탈취되는 경우 보안에 취약해지는 약점이 있습니다.  
이를 방지하기 위해 토큰의 만료기간을 짧게 설정하면 사용자는 토큰이 만료되면 서비스를 이용하는 중에도 재발급받기위해 다시 로그인을 해야합니다.

그렇다고 긴 만료 시간을 주면 보안을 걱정해야합니다.

따라서, 사용자가 로그인을 할 때에 AccessToken과 함께 그에 비해 긴 만료 시간을 갖는 RefreshToken을 클라이언트에 함께 발급합니다. 주로 AccessToken은 30분 내외, RefreshToken은 2주에서 한달 정도의 만료 기간을 부여합니다.

AccessToken이 만료되었다는 오류를 받으면 따로 저장해두었던 RefreshToken을 이용하여 AccessToken을 재발급해줍니다.

RefreshToken의 경우 서버의 stroage에 따로 저장해서 이후 검증에 활용해야 합니다.  
즉, 추가적인 I/O 작업이 필요하다는 의미입니다.  
이는 I/O 작업이 필요없는 빠른 인증 처리를 장점으로 내세우는 JWT에 어울리지 않는 해결 방식입니다.

따라서, DB보다는 보다 속도가 빠르고 가벼운 redis에 저장해보겠습니다.

Redis는 In-Memory 기반의 Key-Value 기반의 NoSql DBMS입니다.

간단하게 (사용자\_id, refreshToken) 정도로 저장할 것이고 In-Memory 방식으로 Memory(Ram)에 저장되기 떄문에 속도가 다른 NoSQL보다 빠릅니다.

따라서, Redis를 사용해보겠습니다.

---

### redis 설정

config 폴더에 redis설정을 해두고 import해 사용하겠습니다.

redisLabs에 생성한 redis-DB와 연동한 후 연결해줍니다.  
(사용법은 생략하겠습니다.)

```js
import redis from "redis";

const redisClient = await redis.createClient({
  // url: "redis://default:java1994@redis-13935.c14.us-east-1-2.ec2.cloud.redislabs.com:13935/0",
  url: `redis://${process.env.REDIS_USERNAME}:${process.env.REDIS_PASSWORD}@${process.env.REDIS_HOST}:${process.env.REDIS_PORT}/${process.env.REDIS_DB_NUM}`,
  legacyMode: true,
});

await redisClient.on("connect", () => {
  console.info("Redis connected!");
});

await redisClient.on("error", (err) => {
  console.error("Redis Client Error", err);
});

await redisClient.connect();

export default redisClient.v4;
```

---

### Redis에 refresh 저장하기

로그인 성공 시 토큰을 발급하면서 redis에 refreshToken을 저장합니다.

```js
import logger from "../middleware/logger.js";
import passport from "passport";
// jwt 유틸 함수 import
import jwtUtil from "../utils/jwt.util.js";
import { createPasswordAndSalt } from "../utils/crypto.util.js";
import UserStorage from "../models/model_user.js";
// redis 설정 import
import redisClient from "../config/redis.js";

const output = {
  ...
};

const process = {
  login: (req, res, next) => {
    passport.authenticate("local-login", (err, user, response) => {
      if (err) return next(err);

      if (!user) return res.json(response);

      return req.logIn(user, { session: false }, async (err) => {
        if (err) return next(err);

        // Access, Refresh 토큰 생성
        const accessToken = jwtUtil.sign(user);
        const refreshToken = jwtUtil.refreshSign(user);

        // redis에 사용자 아이디를 key로 refresh 토큰을 저장합니다.
        await redisClient.set(user.id, refreshToken);

        // 두 토큰을 쿠키로 발급합니다.
        res.cookie("accessToken", accessToken, {
          sameSite: "strict",
          httpOnly: true,
          secure: false,
        });
        res.cookie("refreshToken", refreshToken, {
          sameSite: "strict",
          httpOnly: true,
          secure: false,
        });

        res.status(200).json({ success: true });
      });
    })(req, res, next);
  },

  register: async (req, res, next) => {
    ...
  },

  logout: (req, res) => {
    try {
      // 로그아웃 요청시 토큰을 쿠키에서 삭제합니다.
      res.clearCookie("accessToken", {
        maxAge: 60 * 1000,
        sameSite: "strict",
        httpOnly: true,
        secure: false,
      });

      res
        .clearCookie("refreshToken", {
          maxAge: 60 * 1000,
          sameSite: "strict",
          httpOnly: true,
          secure: false,
        })
        .redirect("/user/login");
    } catch (err) {
      next(err);
    }
  },
};

export default { output, process };

```

---

## jwt 검증 미들웨어 만들기

이제 로그인 성공 시 토큰을 발급하는 것까지 왼료했습니다.

다음은 클라이언트가 발급받은 토큰을 담아 요청했을 때 로그인 없이 서비스를 제공해보겠습니다.
(간단하게 로그인 없이 사용자의 닉네임을 반환해보겠습니다.)

router에서 로그인 페이지를 요청할 때 controller로 가기전 authJwt 미들웨어를 거쳐가도록 구현해보겠습니다.

먼저 라우터 파일입니다.

```js
// routes/user.js
import express from "express";
import ctrl_user from "../controllers/controller_user.js";
import validator_user from "./route_middleware/validator_user.js";
// 구현할 jwt 검증 미들웨어 파일 import
import authJwt from "./route_middleware/jwt_auth.js";

const Router = express.Router();

// 로그인 페이지 GET 요청 시 미들웨어 거쳐가기
Router.get("/login", authJwt, ctrl_user.output.login);

Router.get("/register", ctrl_user.output.register);
Router.get("/logout", ctrl_user.process.logout);

Router.post("/login", validator_user.login, ctrl_user.process.login);
Router.post("/register", validator_user.register, ctrl_user.process.register);

export default Router;
```

미들웨어 파일인 jwt_auth.js는 routes폴더안에 route_middleware폴더에 담아 관리하겠습니다.

검증할 case 3가지

- case 1 : access token이 유효한 경우 => 바로 다음 미들웨어로 넘어감
- case 2 : access token은 만료, refresh token은 유효한 경우 -> access token 재발급
- case 3 : cookie에 토큰이 존재하지 않은 경우

```js
import jwtUtil from "../../utils/jwt.util.js";

const authJwt = async (req, res, next) => {
  try {
    if (req.cookies.accessToken && req.cookies.refreshToken) {
      const accessToken = req.cookies.accessToken;
      const refreshToken = req.cookies.refreshToken;

      // access 토큰 검증 함수
      const accessResult = await jwtUtil.verify(accessToken);

      if (accessResult.success === true) {
        // case 1 :accessToken이 유효한 경우

        //req.user에 토큰 검증으로 얻은 정보를 담아 다음 미들웨어로 보냅니다
        req.user = accessResult;
        next();
      } else {
        // case 2 : accessToken은 만료, refreshToken은 유효한 경우

        // refresh 토큰 검증 함수
        const refreshResult = await jwtUtil.refreshVerify(refreshToken);

        // 검증 성공 시
        if (refreshResult.success === true) {
          // access 토큰 생성
          let newAccessToken = jwtUtil.sign(refreshResult);

          // access 토큰 재발급
          res.cookie("accessToken", newAccessToken, {
            maxAge: 60 * 1000,
            sameSite: "strict",
            httpOnly: true,
            secure: false,
          });

          res.redirect("/user/login");
        }
      }
    } else {
      // case 3 : cookie에 토큰이 존재하지 않은 경우

      // 정보 제공 없이 다음 미들웨어로 보냅니다
      next();
    }
  } catch (err) {
    next(err);
  }
};

export default authJwt;
```

---

## 더 공부할 부분

JWT를 웹에서 저장하기 위해서는 브라우저 저장소에 저장하는 방식과 쿠키에 저장하는 방식을 사용할 수 있습니다.

저장 위치에 따른 보안과, 앱에서 사용하기 위한 방법도 알아보자.

키워드 : XSS, CSRF & CSURF 모듈, request-header
